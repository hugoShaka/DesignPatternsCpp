# DesignPatternsCpp

# Factory.h/cpp
# Implementation of the factory design pattern, in which factory method setLure of base class Lure creates instances of child class objects (representing different types of fishing lures in a tacklebox)

# Adapter.h/cpp
# Implementation of the adapter design pattern, in which a client using weight in pounds may interact through the adapter with an interface expecting mass in kilograms

# Builder.h/cpp
# Implementation of the builder design pattern, in which a truck's characteristics are defined by the member functions of a builder object, which is used by the dealership object to create and supply the truck to the client

# AbstractFactory.h/cpp
# Implementation of the abstract factory design pattern, in which a bank base class is overloaded for various branch names and produces a set of accounts

# Singleton.h/cpp
# Implementation of the singleton design pattern, in which a single instance of class SingletonClass is ensured and provides "read/write" access to member string

# Facade.h/cpp
# Implementation of the facade design pattern, in which an instance of the FacadeClass provides a single interface to subsystems which provide the current date and time

# Mediator.h/cpp
# Implementation of the mediator design pattern, in which the interaction between "stooge" objects, representing the classic slapstick comics The Three Stooges, is encapsulated in a mediator class

# Decorator.h/cpp
# Implementation of the decorator design pattern, in which assault rifle accessories are added to a base class dynamically

# Bridge.h/cpp
# Implementation of the bridge design pattern, in which the interface and implementation specifics for creating fishing lures are abstracted behind LureType and LureCharacteristic base classes

# Try Singleton implementations of Abstract Factory, Builder, Prototype, Facade, and State

# Run through and update comments after finishing all design patterns to review implementation specifics

# Update with Rule of 5 and test it
